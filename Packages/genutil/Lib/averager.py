# Adapted for numpy/ma/cdms2 by convertcdms.py
# Adapted for numpy/ma/cdms2 by convertcdms.py
import numpy, numpy.ma, cdms2, types, string, MV2, genutil
import cdat_info

class AveragerError (Exception):
    def __init__ (self, args=None):
        "Create an exception"
        self.args = args
    def __str__(self):
        "Calculate the string representation"
        return str(self.args)
    __repr__ = __str__


def _check_axisoptions(x, axisoptions):
    """checks the axis=options to make sure that it is valid"""
    axlist = cdms2.orderparse(axisoptions)
    if Ellipsis in axlist:
        raise AveragerError, 'Error: Ellipsis (...) not allowed in axis options'
    try:
        cdms2.order2index(x.getAxisList(), axisoptions)
        return axlist
    except:
        raise AveragerError, 'Error: You have specified an invalid axis= option.'

    
def __myGetAxisWeights(x, i, axisoptions=None):
    """ Assume x is an MV2 duh! and get the weights associated with axis index i.
    index i can be any of the dimensions in x whose bounds are available.
    If bounds are not available then an error is raised.
    """
    if x.getAxis(i).isLatitude():
        Lataxis = x.getAxis(i)
        xgr = cdms2.createGenericGrid(Lataxis[:], numpy.array(range(1), numpy.float), latBounds=Lataxis.getBounds())
        xlatwt, xlonwt = xgr.getWeights()
        return xlatwt
    elif x.getAxis(i).isLongitude():
        Lonaxis = x.getAxis(i)
        xgr = cdms2.createGenericGrid(numpy.array(range(1), numpy.float), Lonaxis[:], lonBounds=Lonaxis.getBounds())
        xlatwt, xlonwt = xgr.getWeights()
        return xlonwt
    else:
        axis_bounds = x.getAxis(i).getBounds()
        if axis_bounds is None:
	    ax=x.getAxis(i)
            if axisoptions is not None:
                axo=cdms2.orderparse(axisoptions)
                if (i in axo ) or (ax.isTime() and 't' in axo) or (ax.isLevel() and 'z' in axo) or ('('+ax.id+')' in axo):
                    raise AveragerError, 'Bounds not available to compute weights on dimension: '+ax.id
                else:
                    axis_wts=numpy.ones(x.getAxis(i)[:].shape)
            else:
                raise AveragerError, 'Bounds not available to compute weights for dimension: '+ax.id
        else:
            axis_wts =  abs(axis_bounds[..., 1] - axis_bounds[..., 0])
        return axis_wts
        # end of if is axis_bounds:
    # end of if x.getAxis(i).isLatitude():

def getAxisWeight(x, i):
    """
    This returns the axis weights as generated by __myGetAxisWeights except it
    is returned as an MV2!
    """
    try:
        wts = __myGetAxisWeights(x, i)
        axis_i = x.getAxis(i)
        wtTV = cdms2.createVariable(wts, axes=[axis_i])
    except:
        raise AveragerError, 'Could not get weights.'
    return wtTV

def __myGetAxisWeightsByName(x, name):
    """ Get the weights associated with axis name.
    The name can be any of the dimensions in x whose bounds are available.
    If bounds are not available then an error is raised. 

    This is a slight modifications on the _myGetAxisWeight. The only difference
    is that the name is used to define the axis instead of the index.
    """
    if x.getAxisList( axes = name )[0].isLatitude():
        Lataxis = x.getAxisList( axes = name )[0]
        xgr = cdms2.createGenericGrid(Lataxis[:], numpy.array(range(1), numpy.float), latBounds=Lataxis.getBounds())
        xlatwt, xlonwt = xgr.getWeights()
        return xlatwt
    elif x.getAxisList( axes = name )[0].isLongitude():
        Lonaxis = x.getAxisList( axes = name )[0]
        xgr = cdms2.createGenericGrid(numpy.array(range(1), numpy.float), Lonaxis[:], lonBounds=Lonaxis.getBounds())
        xlatwt, xlonwt = xgr.getWeights()
        return xlonwt
    else:
        axis_bounds = x.getAxisList( axes = name )[0].getBounds()
        if not axis_bounds:
            raise AveragerError, 'Bounds not available to compute weights'
        else:
            axis_wts =  abs(axis_bounds[..., 1] - axis_bounds[..., 0])
            return axis_wts

def getAxisWeightByName(x, name):
    """
    A hook provided to facilitate the VCDAT GUI.

    This returns the axis weights as generated by __myGetAxisWeights except it
    is returned as an MV2!
    """
    try:
        wts = __myGetAxisWeightsByName(x, name)
        axis_name = x.getAxisList( axes = name )[0]
        wtTV = cdms2.createVariable(wts, axes=[axis_name])
    except:
        raise AveragerError, 'Could not get weights.'
    return wtTV


def area_weights(ds,axisoptions=None):
    '''
    Calculates masked area weights.

    Author: Charles Doutriaux: doutriaux@llnl.gov

    Modified version using CDAT 3.0 by Paul Dubois
    Further modified by Krishna AchutaRao to return weights in all axes.

    Returns a masked array of the same dimensions as ds containing area weights
    but masked where ds is masked.
    '''
    cdat_info.pingPCMDIdb("cdat","genutil.area_weights")
    #
    __DEBUG__ = 0
    #
    if __DEBUG__: print 'Incoming axisoptinos = ', axisoptions
    if __DEBUG__: print 'Shape of Incoming data = ', ds.shape
    seenlon = 0
    seenlat = 0
    if 'x' in list(ds.getOrder()): seenlon = 1
    if 'y' in list(ds.getOrder()): seenlat = 1
    #
    if seenlat and seenlon:
        if __DEBUG__: print 'Found both latitude and longitude'
        initial_order = ds.getOrder()
        if __DEBUG__: print 'initial_order= ', initial_order
        initial_order_list = list(initial_order)
        if '-' in initial_order_list:
            loc = initial_order_list.index('-')
            axisid = '(' + ds.getAxis(loc).id + ')'
            initial_order_list[loc] = axisid
            initial_order = string.joinfields(initial_order_list, '')
            if __DEBUG__: print 'Changed initial_order = ', initial_order
        # end of if '-' in initial_order_list:
        ds = ds(order='...yx')
        dsorder = ds.getOrder()
        if __DEBUG__: print 'Reordered ds ', dsorder        
        Lataxisindex = list(dsorder).index('y')
        Lonaxisindex = list(dsorder).index('x')
        if __DEBUG__: print 'Lataxisindex = ', Lataxisindex, ' Lonaxisindex = ', Lonaxisindex
        #wt = numpy.outer(__myGetAxisWeights(ds,Lataxisindex), __myGetAxisWeights(ds,Lonaxisindex))
        dsgr = ds.getGrid()
        latwts, lonwts = dsgr.getWeights()
        wt = numpy.outer(numpy.array(latwts), numpy.array(lonwts))
        # At this point wt is an nlat by nlong matrix  
        # Now the problem is to propagate this two-dimensional weight mask 
        # through the other dimensions. To do this we shuffle these two dimensions
        # to the front of the shape, resize wt, and then permute it back to 
        # the order of the dimensions in ds.
        s = ds.shape
        for i in range(len(s)-1, -1, -1):
            if (i != Lataxisindex) and (i != Lonaxisindex):
                newaxiswt = __myGetAxisWeights(ds, i,axisoptions)
                wtlist = list(wt.shape)
                if __DEBUG__: print 'Before Inserting newdim', wtlist
                wtlist.insert(0, newaxiswt.shape[0])
                if __DEBUG__: print 'After inserting newdim ', wtlist
                new_wtshape = tuple(wtlist)
                wt = numpy.resize(wt, new_wtshape)
                if __DEBUG__: print 'After inserting dimension ', i, ' shape of wt = ', wt.shape
                new_newaxiswt_shape = list(newaxiswt.shape)
                for nn in range(1, len(wt.shape), 1): new_newaxiswt_shape.append(1)
                newaxiswt = numpy.resize(newaxiswt, tuple(new_newaxiswt_shape))
                wt =  wt * newaxiswt
            # end of if (i != Lataxisindex) and (i != Lonaxisindex):
        # end of for i in range(len(s)):
        wt = cdms2.createVariable(numpy.ma.masked_array(wt, numpy.ma.getmask(ds)), axes=ds.getAxisList())
        result = wt(order=initial_order)
        if __DEBUG__: print 'Returning something of order', result.getOrder()
        return result
    else:
        wt = __myGetAxisWeights(ds, 0, axisoptions)
        if __DEBUG__: print 'Initial', wt.shape
        for i in range(1, len(ds.shape)):
            wt_newshape = tuple(list(ds.shape)[:i+1])
            if __DEBUG__: print 'wt_newshape = ', wt_newshape
            wt = numpy.resize(wt, wt_newshape)
            if __DEBUG__: print 'After wt resize wt.shape = ', wt.shape
            newaxiswt = __myGetAxisWeights(ds, i)
            newaxiswt = numpy.resize(newaxiswt, wt.shape)
            wt = wt * newaxiswt
            if __DEBUG__: print 'After axis ', i, ' wt has shape ', wt.shape
        # end of for i in range(2, len(ds.shape)):
        if __DEBUG__: print 'Final Shape of Weight = ', wt.shape
        return cdms2.createVariable(numpy.ma.masked_array(wt, numpy.ma.getmask(ds)), axes=ds.getAxisList())
    # end of if seenlat and seenlon:



def __check_each_weight_option(x, ax, index, wtopt):
    """
    This does the checking of individual weight options. It fills in the weights
    if 'generate' is an option used i.e if getWeights is needed.
    """
    #
    __DEBUG__ = 0
    #
    if __DEBUG__: print 'Inside __check_each_weight_option, index = ', \
       index, 'axis = ', ax, ' wtopt = ', wtopt
    #
    # Check the types etc.....
    #
    if MV2.isMaskedVariable(wtopt):
        #
        # wtopt is an MV2
        #
        if __DEBUG__: print 'I have a Masked Variable of shape', wtopt.shape
        #
        try:
            if __DEBUG__: print '****Order of axes in wtopt (originally) = ', MV2.getorder(wtopt)
            wtopt = wtopt(order=ax)
            if __DEBUG__: print '****Order of axes in wtopt    (finally) = ', MV2.getorder(wtopt)
        except:
            raise AveragerError, 'The MV2 passed does not have an axis matching '+str(ax)
        # end of try:
        if numpy.ma.shape(wtopt(order=ax)[:])[0] != len(x.getAxis(index)[:]):
            # We have an MV2 whose length is not the same as that of the corresponding axis for x
            raise AveragerError, \
                  'The Masked Variable passed does not match the length of axis ' + str(ax)
        # end of if numpy.ma.shape(wtopt(order=ax)[:])[0] != len(x.getAxis(index)[:]):
        if len(numpy.ma.shape(wtopt)) == 1:
            #
            # Coerce the MV2 to numpy type..... only if the wtopt is 1-d!!
            #
            if __DEBUG__: print 'Returning a numeric array from MV2!!'
            wtopt = numpy.ma.filled(wtopt)
        # end of if len(numpy.ma.shape(wtopt)) == 1:
    elif numpy.ma.isMA(wtopt):
        #
        # wtopt is an numpy.ma
        #
        if __DEBUG__: print 'I have a Masked Array of rank', wtopt.ndim
        #
        if wtopt.ndim > 1:
            raise AveragerError, \
                 'Error: The Masked Array of more than 1 dimension lacks sufficient information'
        # end of if numpy.ma.rank(wtopt) > 1:
        if numpy.ma.shape(wtopt)[0] != len(x.getAxis(index)[:]):
            raise AveragerError, 'Error: Axis is of length %d, weights passed of length %d.' %\
            (len(x.getAxis(index)[:]), numpy.ma.shape(wtopt)[0])
        # end of if numpy.ma.shape(wtopt)[0] != len(x.getAxis(index)[:]):
        #
        # Coerce the numpy.ma to numpy type.....
        #
        if __DEBUG__: print 'Returning a numeric array from numpy.ma!!'
        wtopt = wtopt.filled()
    elif isinstance(wtopt, numpy.ndarray):
        #
        # wtopt is a numpy Array
        #
        if __DEBUG__: print 'I have a numpy Array of rank', len(numpy.shape(wtopt))
        #
        if len(numpy.shape(wtopt)) > 1:
            raise AveragerError, \
            'Error: The numpy Array of more than 1 dimension lacks sufficient information'
        if numpy.shape(wtopt)[0] != len(x.getAxis(index)[:]):
            raise AveragerError, 'Error: Axis is of length %d, weights passed of length %d' % \
            (len(x.getAxis(index)[:]), numpy.shape(wtopt)[0])
    elif isinstance(wtopt, types.StringType):
        #
        # wtopt is a string
        #
        if __DEBUG__: print 'I have a string =', wtopt
        #
        if wtopt.lower() in ['equal','unweighted']:
            if __DEBUG__: print 'Equal weights specified'
            wtopt = 'unweighted'
        elif wtopt.lower() in ['generate','weighted']:
            # NOTE: THIS FUNCTION CAN BE CHANGED WHEN BOB PUTS THE FUNCTION getAxisWeights() INTO cdms2
            if __DEBUG__: print 'GENERATE weights specified'            
            wtopt = __myGetAxisWeights(x, index)
            if __DEBUG__: print wtopt
        else:
            raise AveragerError, 'Error: Unrecognised string option specified'
    # end of if MV2.isMaskedVariable(wtopt):
    return wtopt


def __check_weightoptions(x, axisoptions, weightoptions):
    """
    Checks the weights=options to make sure that it is valid.
    
    Default: 'weighted'
    
    weight options are one of 'weighted', 'unweighted',  an array of weights for each 
    dimension or a MaskedVariable of the same shape as the data x.
    - 'weighted' means use the grid information to generate weights for that
      dimension or if multiple axes are passed, generate goes ahead and
      generates the full masked area weights.
    - 'unweighted' means use equal weights for all the grid points in that axis. 
    - Also an array of weights (of the same shape as the dimension being 
      averaged over or same shape as V) can be passed.
    """
    #
    # Since the _check_axisoptions was passed, the variable x has already been reordered
    # to the required order..... check it anyway.
    #
    #
    __DEBUG__ = 0
    #
    if __DEBUG__: print 'Axis options entering __check_weightoptions = ', axisoptions
    #
    axisindex = cdms2.order2index(x.getAxisList(), axisoptions)
    if __DEBUG__: print 'This should be 0,1,2... etc. is it? ', axisindex
    #
    axislist = cdms2.orderparse(axisoptions)
    if __DEBUG__: print 'axislist = ', axislist
    #
    if not isinstance(weightoptions, types.ListType):
        #
        # We have either 1 axis only or multiple axes and one MV2 of weights
        #
        if MV2.isMaskedVariable(weightoptions):
            #
            # Weight passed is an MV2. Probably OK
            #
            try:
                # We had required that the weights be of the same rank as the variable to be averaged.
                weightoptions = weightoptions(order=axisoptions)
                #
                # KRISHNA : check this for combinewts!!
                #
##                 if x.shape != weightoptions.shape:
##                     raise AveragerError, \
##                           'Error: Shape of weight array does not match shape of data array'
##                 # end of if x.shape != weightoptions.shape:
                if __DEBUG__: print '... definitely OK'
            except:
                raise AveragerError, \
                      'Error: Did not find the axes requested in the Masked variable.'
        elif len(axislist) == 1:
            #
            # Only one axis to reduce over....'
            # figure out if it is an array (numpy or numpy.ma) or 'equal' or 'generate' or something else
            #
            if __DEBUG__: print 'I have only 1 axis and 1 option'
            weightoptions = __check_each_weight_option(x, axislist[0], axisindex[0], weightoptions)
        else:
            #
            # More than 1 axis to reduce over, and not an MV2 of the same dimensionality as x!
            #
            if weightoptions in ['generate','weighted']:
                weightoptions = area_weights(x,axisoptions)
            else:
                # Cannot do this because 'generate' was not passed with multiple axes.
                raise AveragerError, 'Error: Multiple axes passed without weights to match'
            # end of if weightoptions == 'generate':
    else:
        #
        # I have a list of weightoptions i.e more than 1 axis in axisoption
        #
        #
        # We have multiple axes to deal with each with a weight....
        #
        for i in range(len(axislist)):
            weightoptions[i] = __check_each_weight_option(x, axislist[i], axisindex[i], weightoptions[i])
        # end of for i in range(len(axislist)):
        #
        if len(axislist) < len(weightoptions):
            for j in range(len(axislist), len(weightoptions), 1):
                weightoptions[j] = __check_each_weight_option(x, None, j, weightoptions[j])
        # end of if len(axislist) < len(weightoptions):
    # end of if not isinstance(weightoptions, types.ListType):
    #
    if __DEBUG__: print 'Successful with __check_weightoptions'
    #
    return weightoptions




def _check_MA_weight_options(weightoptions, shx, N_axisopt):
    """
    Check the weight options for the case of an MA passed to averager.

    Inputs:
      weightoptions : The user specified options in weights = 
      shx           : Is the shape of the reordered numpy.ma
    """
    #
    __DEBUG__ = 0
    #
    if __DEBUG__: print 'Entered _check_MA_weight_options:', weightoptions
    #
    if weightoptions is None:
        weightoptions = [None] * N_axisopt
    # 
    if not isinstance(weightoptions, types.ListType):
        weightoptions = [weightoptions]
    # end of if not isinstance(weightoptions, types.ListType):
    #
    for i in range(len(weightoptions)):
        #
        wt = weightoptions[i]
        #
        if isinstance(wt, types.StringType):
            if __DEBUG__: print 'string weights'
            if wt in ['weighted', 'generate']:
                raise AveragerError, \
                      'Cannot generate weights for an numpy.ma. %s is not a valid option when you do not pass an MV2. ' % wt
            elif (wt in ['equal', 'unweighted']):
                weightoptions[i] = numpy.ones(tuple([shx[i]]), numpy.float)
            # end of if wt in ['weighted', 'generate']:
        elif isinstance(wt, numpy.ndarray) :
            if __DEBUG__: print 'numpy Array weights'
            if (wt.shape != shx) and (wt.ndim == 1 and len(wt) != shx[i]):
                raise AveragerError, 'The passed weight is not of the appropriate shape'
            # end of if (wt.shape != shx) or (numpy.ma.rank(wt) == 1 and len(wt) != shx[i]):
        elif numpy.ma.isMA(wt) :
            if __DEBUG__: print 'numpy.ma Array weights'
            if __DEBUG__: print 'wt.shape = ', wt.shape
            if __DEBUG__: print 'numpy.ma.rank(wt) = ', wt.ndim
            if __DEBUG__: print 'len(wt) = ', len(wt)
            if __DEBUG__: print 'shx[i] = ', shx[i]
            if (wt.shape != shx) and (wt.ndim == 1 and len(wt) != shx[i]):
                if __DEBUG__: print 'The passed weight is not of the appropriate shape'
                raise AveragerError, 'The passed weight is not of the appropriate shape'
            # end of if (wt.shape != shx) or (numpy.ma.rank(wt) == 1 and len(wt) != shx[i]):
        # end of if isinstance(wt, types.StringType):
    # end of for i in range(len(weightoptions)):
    #
    if __DEBUG__: print 'weightoptions after _check_MA_weight_options', weightoptions
    return weightoptions



def _combine_weights(x, weightoptions):
    """
    This takes in the shape of the reordered array, the passed weight options
    and combines the weights to form a weight array of the same shape as x.

    Inputs:
      x             : The input array reordered to be in the order of operations.
      weightoptions : The weight options for the subset of axes of x - in the order of x

    Returned:
      weight_array  : In the same shape as x but assuming that the remaining weights are equal.
    """
    #
    __DEBUG__ = 0
    #
    xsh = x.shape
    if __DEBUG__: print 'Shape of incoming data x ', xsh
    if __DEBUG__: print 'Type of x ', x.__class__
    #
    if isinstance(weightoptions, types.ListType):
        if __DEBUG__: print 'weightoptions is a list'
        #
        # Note the weight options have already gone through checks against the
        # reordered data. So nofurther checks are necessary!
        #
        n_dimstoadd = len(x.shape) - len(weightoptions)
        if __DEBUG__: print 'Dimensions to add = ', n_dimstoadd
        if n_dimstoadd < 0 :
            raise AveragerError, 'Error in weights list - too many weights passed!'
        elif n_dimstoadd > 0:
            init_shape = x.shape[-n_dimstoadd:]
            if __DEBUG__: print 'Initialized shape = ', init_shape
            #
            wt_init = numpy.ones(init_shape, numpy.float)
            #
            dim = len(init_shape) + 1
        else:
            wt_init = None
            dim = 1
        # end of if n_dimstoadd < 0 :
        #
        wgt = weightoptions[-1]
        if wgt in ['equal', 'unweighted']:
            wgt = numpy.ones(xsh[-dim], numpy.float)
        else:
            if __DEBUG__ : print wgt
        # end of if wgt in ['equal', 'unweighted']:
        #
        if __DEBUG__: print 'wgt.shape = ', wgt.shape
        #
        if wt_init is None:
            wt_init = wgt
            if not isinstance(wt_init, numpy.ndarray): raise AveragerError, 'Wrong Weight!!!'
        else:
            if __DEBUG__ : print 'list(init_shape) = ', list(init_shape)
            newshape = list(init_shape)
            newshape.insert(0, wgt.shape[0])
            if __DEBUG__: print 'Pre-loop newshape ', newshape
            wt_init = numpy.resize(wt_init, tuple(newshape))
            if __DEBUG__: print 'Pre-loop wt_init.shape ', wt_init.shape
            wgtsh = list(wgt.shape)
            for nn in range(1, len(wt_init.shape), 1): wgtsh.append(1)
            if __DEBUG__: print 'wgt resized to ', tuple(wgtsh)
            wgt = numpy.resize(wgt, tuple(wgtsh))
            wt_init = wt_init * wgt
        # end of if not wt_init:
        #
        if __DEBUG__: print 'Pre-loop wt_init.shape ', wt_init.shape
        #
        for i in range(len(weightoptions)-2, -1, -1):
            dim_wt = weightoptions[i]
            if dim_wt in ['equal', 'unweighted']:
                dim_wt = numpy.ones(xsh[i], numpy.float)
            # end of if dim_wt in ['equal', 'weighted']:
            if __DEBUG__: print 'At step ', i, dim_wt
            #wt_init = numpy.outer(wt_init, dim_wt)
            newshape = list(wt_init.shape)
            newshape.insert(0, dim_wt.shape[0])
            wt_init = numpy.resize(wt_init, tuple(newshape))
            if __DEBUG__: print 'Shape of wt_init = ', wt_init.shape
            dim_wtsh = list(dim_wt.shape)
            for nn in range(1, len(wt_init.shape), 1): dim_wtsh.append(1)
            if __DEBUG__: print 'dim_wt resized to ', tuple(dim_wtsh)
            dim_wt = numpy.resize(dim_wt, tuple(dim_wtsh))            
            wt_init = wt_init * dim_wt
        # end of for i in range(len(weightoptions)-1, -1, -1):
        #
        if __DEBUG__: print 'wt_init after all dimensions adeed has shape ', wt_init.shape
        if wt_init.shape != xsh: raise AveragerError, 'SOMETHING SCREWY HAPPENED!!'
        #
        if MV2.isMaskedVariable(x): wt_init = MV2.array(wt_init, axes=x.getAxisList())
        weightoptions = [wt_init]
        #
        if __DEBUG__: print 'Are my weight and area_weights the same?', numpy.ma.allclose(weightoptions[0], area_weights(x))
    elif MV2.isMaskedVariable(weightoptions):
        if __DEBUG__: print 'weightoptions is an MV2. Nothing to do?'
    elif numpy.ma.isMaskedArray(V) and not MV2.isMaskedVariable(V):
        if __DEBUG__: print 'weightoptions is an MA. Nothing to do?'
    else:
        if __DEBUG__: print 'weightoptions is something else. Nothing to do?'
    # end of if isinstance(weightoptions, types.ListType):
    #
    return weightoptions



def _check_MA_axisoptions(axisoption, N_dim):
    """
    This checks the axis options for the case of an MA passed to the averager.
    
    Inputs:
      axisoption : The user specified options in axis=
      N_dim      :  rank of the MA that is being averaged

    Returned:
      axisoption : This one is always a list of integers pertaining to axes
    """
    #
    __DEBUG__ = 0
    #
    if __DEBUG__: print 'Inside _check_MA_axisoptions:', axisoption
    #
    if not isinstance(axisoption, types.ListType):
        axisoption = [axisoption]
    # end of if not isinstance(axis, types.ListType):
    #
    for i in range(len(axisoption)):
        axis = axisoption[i]
        if not axis:
            axisoption[i] = 0
        elif isinstance(axis, types.IntType):
            if axis not in range(N_dim):
                raise AveragerError, 'Specified dimension \'%d\' not valid in array of rank %d' % (axis, N_dim)
            # end of if axis >= len(N_dim):
        elif isinstance(axis, types.StringType):
            try:
                axisoption[i] = int(axis)
            except:
                raise AveragerError, \
                      '%s is not a valid axis for an MA. You must pass an MV2' % axis
            # end of try:
        # end of if axis is None:
    # end of for axis in axisoption:
    #
    if __DEBUG__: print 'axisoption after _check_MA_axisoptions = ', axisoption, len(axisoption)
    #
    return axisoption

    
def sum_engine(x, wts):
    """
    The work horse that does the summing ! This is specific to summing.
    We will always be dealing with the first dimension.....and x is already in
    the order we will sum.
    1-d wts are always numpy arrays or 'equal' Multi-dimensional arrays are
    always MV2's
    
    Inputs:
        x   : the input array (can be MV2 or MA)
        wts : the input weight array (numpy array or MV2 or 'equal')
        
    Returned:
        y          : The weighted sum (summed over the first dimension)
        return_wts : The sum of weights (summed over the first dimension)
    """
    #
    __DEBUG__ = 0
    #
    if x is None: return None
    if wts is None: return None
    #
    shx = numpy.ma.shape(x)
    #
    if __DEBUG__: print '\tInside sum_engine.'
    if __DEBUG__: print '\tIncoming data of shape ', shx
    #
    if MV2.isMaskedVariable(wts) or isinstance(wts, numpy.ndarray):
        #
        # wts is an MV2 or numpy array 
        #
        if __DEBUG__: print '\t********** Weight is an MV2 or numpy array! **********'
        #
        xavg, return_wts = MV2.average(x, weights=wts, returned=1, axis=0)
        y = xavg * return_wts
        return y, return_wts
    elif wts in ['equal','unweighted']:
        #
        # Equal weights
        #
        if __DEBUG__: print '\t********** Weight is Equal! **********'
        xavg, return_wts = MV2.average(x, returned=1, axis=0)
        y = xavg * return_wts
        return y, return_wts
        # end of if action == 'sum':
    else:
        raise AveragerError, 'wts is an unknown type in sum_engine'
        return None
    # end of if MV2.isMaskedVariable(wts) or isinstance(wts, numpy.ndarray):

    
def average_engine(x, wts):
    """
    The work horse that does the averaging! This is specific to averageing.
    We will always be dealing with the first dimension.....and x is already in
    the order we will average.
    1-d wts are always numpy arrays or 'equal' Multi-dimensional arrays are
    always MV2's
    """
    #
    __DEBUG__ = 0
    #
    if x is None: return None
    if wts is None: return None
    #
    shx = numpy.ma.shape(x)
    if __DEBUG__: print '\tInside average_engine.'
    if __DEBUG__: print '\tIncoming data of shape ', shx
    #
    if MV2.isMaskedVariable(wts) or isinstance(wts, numpy.ndarray):
        y, return_wts = MV2.average(x, weights=wts, returned=1, axis=0)
        return y, return_wts
    elif wts in ['equal','unweighted']:
        y, return_wts = MV2.average(x, returned=1, axis=0)
        return y, return_wts
    else:
        raise AveragerError, 'wts is an unknown type in average_engine'
        return None
    # end of if MV2.isMaskedVariable(wts) or isinstance(wts, numpy.ndarray):



def averager(V, axis=None, weights=None, action='average', returned=0, weight=None, combinewts=None):
    """
                        Documentation for averager():
                        -----------------------------
The averager() function provides a convenient way of averaging your data giving
you control over the order of operations (i.e which dimensions are averaged
over first) and also the weighting for the different axes. You can pass your
own array of weights for each dimension or use the default (grid) weights or
specify equal weighting. 


Author: Krishna AchutaRao : achutarao1@llnl.gov

Returns:
-------
       The average over the specified dimensions.
Usage: 
------
from cdutil import averager
averager( V, axis='axisoptions', weights=weightoptions, action='average',
          returned='0')

Where V is an array. It can be an array of numpy, numpy.ma or MV2 type. In each case
the function returns an array (except when it results in a scalar) of the same
type as V. See examples for more details.

Optional Arguments:
-------------------
axis=axisoptions   
        Restrictions: axisoptions has to be a string
        Default : first dimension in the data you pass to the function.

        You can pass axis='tyx', or '123', or 'x (plev)' etc.  the same way as
        in order= options for variable operations EXCEPT that
        '...'(i.e Ellipses) are not allowed. In the case that V is a numpy or
        numpy.ma array, axis names have no meaning and only axis indexes are valid.


weights=weightoptions
        Default :
                 'weighted' for Transient Variables (MV2s)
                 'unweighted' for numpy.ma or numpy arrays.

        Note that depending on the array being operated on by averager, the
        default weights change!
        
        Weight options are one of 'weighted', 'unweighted',  an array of weights for
        each dimension or a MaskedVariable of the same shape as the data x.

        - 'weighted' means use the grid information to generate weights for
          that dimension.

        - 'unweighted' means use equal weights for all the grid points in that axis. 

        - Also an array of weights (of the same shape as the dimension being
          averaged over or same shape as V) can be passed.

          Additional Notes on 'weighted' option: The weights are generated
          using the bounds for the specified axis. For latitude and Longitude,
          the weights are calculated using the area (see the cdms2 manual
          grid.getWeights() for more details) whereas for the other axes
          weights are the difference between the bounds (when the bounds are
          available). If the bounds are stored in the file being read in, then
          those values are used. Otherwise, bounds are generated as long as
          cdms2.setAutoBounds('on') is set. If cdms2.setAutoBounds() is set to
          'off', then an Error is raised.

action='average' or 'sum'
        Default : 'average'

        You can either return the weighted average or the weighted sum of the
        data by specifying the keyword argument action=
        
returned = 0 or 1
        Default: 0
        
        - 0 implies sum of weights are not returned after averaging operation.
        - 1 implies the sum of weights after the average operation is returned.

combinewts = None, 0 or 1
        Default: None - same as 0
        - 0 implies weights passed for individual axes are not combined into one
          weight array for the full variable V before performing operation.
       - 1 implies weights passed for individual axes are combined into one
         weight array for the full variable before performing average or sum
         operations. One-dimensional weight arrays or key words of 'weighted' or
         'unweighted' must be passed for the axes over which the operation is
         to be performed. Additionally, weights for axes that are not being
         averaged or summed may also bepassed in the order in which they appear.
         If the weights for the other axes are not passed, they  are assumed to
         be equally weighted.

Examples:
---------
        >>> f = cdms2.open('data_file_name')
        >>> averager(f('variable_name'), axis='1')
        # extracts the variable 'variable_name' from f and averages over the 
        # dimension whose position is 1. Since no other options are specified, 
        # defaults kick in i.e weight='weighted' and returned=0

        >>> averager(V, axis='xy', weights=['weighted','unweighted'])
        or
        >>> averager(V, axis='t', weights='unweighted')
        or
        >>> averager(V, axis='x')
        # Default weights option of 'weighted' is implemented
        or
        >>> averager(V, axis='x', weights=mywts) 
        # where mywts is an array of shape (len(xaxis)) or shape(V)
        or
        >>> averager(V, axis='(lon)y', weights=[myxwts, myywts])
        # where myxwts is of shape len(xaxis) and myywts is of shape len(yaxis)
        or
        >>> averager(V, axis='xy', weights=V_wts)
        # where V_wts is a Masked Variable of shape V
        or
        >>> averager(V, axis='x', weights='unweighted', action='sum')
        # will return the equally weighted sum over the x dimension
        or
        >>> ywt = area_weights(y)
        >>> fractional_area = averager(ywt, axis='xy',
                                weights=['unweighted', 'unweighted'], action='sum')
        # is a good way to compute the area fraction that the
        # data y that is non-missing
        
Note:
-----
        When averaging data with missing values, extra care needs to be taken.
        It is recommended that you use the default weights='weighted' option.
        This uses cdutil.area_weights(V) to get the correct weights to
        pass to the averager.
        >>> averager(V, axis='xy', weights='weighted')
        
        The above is equivalent to:
        >>> V_wts = cdutil.area_weights(V)
        >>> result = averager(V, axis='xy', weights=V_wts)
        or
        >>> result = averager(V, axis='xy', weights=cdutil.area_weights(V))

        However, the area_weights function requires that the axis bounds are
        stored or can be calculated (see documentation of area_weights for more
        details). In the case that such weights are not stored with the axis
        specifications (or the user desires to specify weights from another
        source), the use of combinewts option can produce the same results.
        In short, the following two are equivalent:
        >>> xavg_1 = averager(X, axis = 'xy', weights = area_weights(X))
        >>> xavg_2 = averager(X, axis = 'xy', weights = ['weighted', 'weighted', 'weighted'], combinewts=1)

        Where X is a function of x, y and a third dimension such as time or level.
        
        In general, the above can be substituted with arrays of weights where
        the 'weighted' keyword appears.
        """
    __DEBUG__ = 0
    cdat_info.pingPCMDIdb("cdat","genutil.averager")
    #
    # Check the weight = option. This is done for backward compatibility since
    # weights= is the current default syntax.
    #
    if not weight is None:
        if not weights is None:
            raise AveragerError, \
                  'Error: You cannot set both weight and weights!. weight is obsolete please use weights only !!!'
        else:
            weights = weight
        # end of if not weights in ['generate','weighted'] :
    # end of if not weight is None:
    #
    # Note: Further checking on weights is done later - in the numpy.ma & MV2 sections also.
    #
    # Check the returned option
    #
    if returned not in [0,1]:
        raise AveragerError, \
              'Error: Invalid option for returned. Pass 0 or 1.'
    # end of if returned not in [0,1]:
    #
    # Check the action = options
    #
    if string.upper(action) in ['AVERAGE', 'AVE', 'AVG']:
        action = 'average'
    elif string.upper(action) in ['SUM', 'ADD']:
        action = 'sum'
    else:
        raise AveragerError, 'Error: Invalid option for action. Pass \'average\' or \'sum\''
    # end of if string.upper(action) in ['AVERAGE', 'AVE', 'AVG']:
    #
    # Check the combinewts option
    #
    if not combinewts :
        combinewts = 0
    elif combinewts not in [0, 1]:
         raise AveragerError, \
               "Error: combinewts must be set to 0 or 1"
    # end of if not combinewts :
    # ************************* End of option checking ************************* 
    #
    # Account for MV2, numpy.ma or numpy arrays sent in by users. Return result of same type.
    #
    #
    # Case 1. numpy array
    #         Convert numpy array to numpy.ma and remember it using _NUM_FLAG so you
    #         can convert the answer to numpy array before returning
    #
    if isinstance(V, numpy.ndarray):
        if __DEBUG__: print 'Converting to numpy.ma so I can do an numpy.ma.average or sum'
        V = numpy.ma.array(V)
        _NUM_FLAG = 1
    else:
        _NUM_FLAG = 0
    # end of if isinstance(V, numpy.ndarray):
    #
    #
    # Case 2. Masked Array (numpy.ma)
    #
    if numpy.ma.isMaskedArray(V) and not MV2.isMaskedVariable(V):     
        #
        # The passed array is an numpy.ma
        #
        if __DEBUG__: print 'Entered numpy.ma only....'
        if __DEBUG__: print '!!!!!!Checking weights for numpy.ma', weights
        #
        #
        if isinstance(weights, types.StringType) and weights in ['weighted', 'generate']:
            if __DEBUG__: print 'VOILA!'
            print 'cdutil.averager Warning: \n\tNot operating on a TransientVariable.'
            print '\tChanging default weights to \'unweighted\' (equally weighted)'
            weights = None
        # end of if weights == 'weighted':
        #
        # Check the axis options.
        #
        axis = _check_MA_axisoptions(axis, V.ndim)
        #
        # Now reorder the original MA to the order in which operations need to be done
        #
        newaxorder = []
        for i in axis:
            newaxorder.append(i)
        # end of for i in axis:
        for i in range(len(V.shape)):
            if not i in newaxorder:
                newaxorder.append(i)
            # if not i in newaxorder:
        # end of for i in range(len(numpy.ma.shape(V))):
        #doloop = False
        if newaxorder != range(len(V.shape)):
            x = numpy.ma.transpose(V, newaxorder)
            if __DEBUG__: print 'Reordered shape = ', x.shape
            #osh=list(x.shape)
            #na=len(axis)
            #if n!=x.rank():
            #    nsh=osh[:na] # the axes of operations....
            #    n=1
            #    for m in osh[na:]:
            #        n*=m
            #    nsh.append(n)
            #    x = numpy.ma.reshape(x,nsh)
            #    if n>35000000:
            #        doloop=
        else:
            x = V

        
        # end of if newaxorder != range(len(V.shape)):
        #
        # Check the weight options
        #
        weights = _check_MA_weight_options(weights, x.shape, len(axis))
        #
        #
        if __DEBUG__: print 'Length of axis = ', len(axis)
        if __DEBUG__: print 'Length of weights = ', len(weights)
        #
        # If the user has passed combinewts = 1, then do the combining of weights here
        #
        if combinewts == 1:
            weights = _combine_weights(x, weights)
        # end of if combinewts == 1:
        #
        # Now decide if we need to average or sum
        #
        if action == 'average':
            #
            # The actual averaging.........
            #
            for i in range(len(axis)):
                #
                if __DEBUG__: print 'Averaging axis # = ', i,
                #
                if  isinstance(weights[i] , types.StringType) or (weights[i] is None):
                    pass
                else:
                    if __DEBUG__: print weights[i].shape
                # end of if not isinstance(weights[i] , types.StringType):
                if i > len(weights)-1:
                    if not retwts:
                        raise AveragerError, 'An unknown error occurred (retwts). Report this bug.'
                    else:
                        weights.append(retwts)
                    # end of if not retwts:
                # end of if i > len(weights)-1:
                try:
                    x, retwts = numpy.ma.average(x, weights=weights[i], returned=1, axis=0)
                except:
                    raise AveragerError, 'Some problem with averaging MA'
                #
            # end of for i in range(len(axis)):
        elif action == 'sum':
            #
            # Come to sum function here
            #
            for i in range(len(axis)):
                if __DEBUG__: print 'Summing axis #', i
                if i > len(weights)-1:
                    try:
                        x = numpy.ma.sum(x, returned=0, axis=0)
                        retwts = numpy.ma.sum(retwts, axis=0)
                    except:
                        raise AveragerError, 'Some problem with summing numpy.ma'
                    # end of try:
                else:
                    try:
                        x, retwts = numpy.ma.average(x, weights=weights[i], returned=1, axis=0)
                        x = x * retwts
                    except:
                        raise AveragerError, 'Some problem with summing numpy.ma'
                    # end of try:
                # end of if i > len(filled_wtoptions):            
                if __DEBUG__: print 'Finished Summing axis #', i
            # end of for i in range(N_axes):
        # end of if action == 'sum':
        #
        # If we started out with a numpy array, convert the numpy.ma to numpy
        #
        if _NUM_FLAG:
            if numpy.ma.isMaskedArray(x):
                x = x.filled()
            # end of if numpy.ma.isMaskedArray(x):
            #
            if numpy.ma.isMaskedArray(retwts):
                retwts = retwts.filled()
            # end of if numpy.ma.isMaskedArray(retwts):
        # end of if _NUM_FLAG:
        #
        if returned:
            return x, retwts
        else:
            return x
        # end of if returned:
        #
        return None
    # end of if numpy.ma.isMaskedArray(V):
    #
    #******************************************************************************************
    #
    # Case 3: Masked Variable.
    #
    if weights is None: weights = 'weighted'
    #
    axis_order = []
    if __DEBUG__: print 'Inside averager axis = ', axis
    if axis == None:
        if __DEBUG__: print 'Default axis is the first axis.........'
        axis = V.getOrder()[0]
        axis_order.append(axis)
    else:
        if type(axis)==type(0): axis=str(axis)
        axis_order = _check_axisoptions(V, axis)
        if __DEBUG__: print 'Axes to be addressed in the order ', axis_order
        for an in range(len(axis_order)):
            item = axis_order[an]
            if isinstance(item, types.IntType):
                loc = string.find(axis, str(item))
                if loc != -1:
                    xlist = list(axis)
                    xlist[loc] = V.getOrder()[item]
                    if xlist[loc] == '-': xlist[loc] = '(' + V.getAxis(item).id + ')'
                    if __DEBUG__: print '*** the axisoption is about to be modified. Before mod  = ', axis 
                    axis = string.joinfields(xlist, '')
                    if __DEBUG__: print '*** the axisoption has been modified. It is = ', axis
            # end of if type(item) = type(1):
        # end of for an in range(len(axis_order)):
        if __DEBUG__: print 'NEW! Axes to be addressed in the order ', axis_order
        if axis_order != None:
            if __DEBUG__: print 'axis = ', axis
            V= V(order=axis)
            if __DEBUG__: print '********** I have reordered V= V(order=axis) **********'
        else:
            return None
        # end of if axis_order != None:
    # end of if axis == None:
    #
    if __DEBUG__: print 'Passed axis checks......'
    if __DEBUG__: print 'Axes to be addressed in the order ', axis_order
    #
    # Number of axes to average/sum over = len(axis_order)
    #
    N_axes = len(axis_order)    
    #
    # Parse the weights = options
    #
    if __DEBUG__: print 'Checking weights= options:',weights
    #
    filled_wtoptions = __check_weightoptions(V, axis, weights)
    if __DEBUG__: print 'The weights options are ', filled_wtoptions
    #
    if not isinstance(filled_wtoptions, types.ListType):
        filled_wtoptions = [filled_wtoptions]
    # end of if not isinstance(filled_wtoptions, types.ListType):
    #
    # 
    if __DEBUG__: print 'Length of axis_order = ', N_axes
    if __DEBUG__: print 'Length of filled_wtoptions = ', len(filled_wtoptions)
    #
    # If the user has passed combinewts = 1, then do the combining of weights here
    #
    if combinewts == 1:
        filled_wtoptions = _combine_weights(V, weights)
    # end of if combinewts == 1:
    #
    # Now decide if we need to average or sum
    #
    if __DEBUG__: print 'type(weights) = ', type(weights)
    try:
        if __DEBUG__: print 'Are they equal?', MV2.allclose(weights, area_weights(V,axisoptions))
    except:
        pass
    #
    if action == 'average':
        #
        # Come to averaging function here....
        #
        for i in range(N_axes):
            #
            if __DEBUG__: print 'Averaging axis #', i
            #
            if i > len(filled_wtoptions)-1:
                if sumwts is None:
                    raise AveragerError, 'An unknown error occurred (sumwts). Report this bug.'
                else:
                    filled_wtoptions.append(sumwts)
                # end of if not sumwts:
            # end of if i > len(filled_wtoptions):
            V, sumwts = average_engine(V, filled_wtoptions[i])
            if __DEBUG__: print 'Finished Averaging axis #', i
        # end of for i in range(N_axes):
        if returned == 1:
            return V, sumwts
        else:
            return V
        # end of if returned == 1:
    elif action == 'sum':
        #
        # Come to sum function here
        #
        for i in range(N_axes):
            if __DEBUG__: print 'Summing axis #', i
            if i > len(filled_wtoptions)-1:
                V, dummy_wts = sum_engine(V, 'unweighted')
                sumwts = MV2.sum(sumwts, axis=0)
            else:
                V, sumwts = sum_engine(V, filled_wtoptions[i])
            # end of if i > len(filled_wtoptions):            
            if __DEBUG__: print 'Finished Summing axis #', i
        # end of for i in range(N_axes):
        y = V
        # end of if len(filled_wtoptions) == 1:
        if returned == 1:
            return y, sumwts
        else:
            return y
        # end of if returned == 1:
    # end of if action == 'average':
